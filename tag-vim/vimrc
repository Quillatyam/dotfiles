" .vimrc of Robert den Harink

call plug#begin('~/.vim/plugged')

" Autocompletion with deoplete
Plug 'Shougo/deoplete.nvim'
Plug 'roxma/nvim-yarp'
Plug 'roxma/vim-hug-neovim-rpc'
Plug 'wellle/tmux-complete.vim'

Plug 'tpope/vim-sensible'
Plug 'kien/ctrlp.vim'
Plug 'scrooloose/nerdcommenter'
Plug 'scrooloose/nerdtree'
Plug 'ervandew/supertab'
Plug 'vim-syntastic/syntastic'
Plug 'godlygeek/tabular'
Plug 'tomtom/tlib_vim'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'vim-erlang/vim-erlang-runtime'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'garbas/vim-snipmate'
Plug 'troydm/easybuffer.vim'
Plug 'majutsushi/tagbar'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'
Plug 'christoomey/vim-tmux-navigator'
Plug 'thaerkh/vim-workspace'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'ludovicchabant/vim-gutentags'
Plug 'jreybert/vimagit'
Plug 'airblade/vim-gitgutter'
Plug 'rhysd/git-messenger.vim'
Plug 'vim-airline/vim-airline'
Plug 'ledger/vim-ledger'

Plug 'reedes/vim-pencil' " Super-powered writing things
Plug 'tpope/vim-abolish' " Fancy abbreviation replacements
Plug 'junegunn/limelight.vim' " Highlights only active paragraph
Plug 'junegunn/goyo.vim' " Full screen writing mode
Plug 'reedes/vim-lexical' " Better spellcheck mappings
Plug 'reedes/vim-litecorrect' " Better autocorrections
Plug 'reedes/vim-textobj-sentence' " Treat sentences as text objects
call plug#end()

" Hide buffer instead of unloading it.
" This fixes nagging 'No write since last change' when switching buffers
set hidden

" Configure persistent undo
" Vim will save undo in file stored in .vim/undodir
set undodir=~/.vim/undodir
set undofile

" Complete command line on longest substring,
" then list alternatives
set wildmode=longest,list

" Spelling auto suggestion
set complete+=kspell

" Always show sign for gitgutter
set signcolumn=yes

" Always use the clipboard for all operations
set clipboard+=unnamed

" Search continues over end of file
set wrapscan

" Show line numbers
set number

" Don't show spaces.
" Trailing whitespace is handled by sensible plugin.
set nolist

" Indentation settings
set autoindent
set tabstop=4
set shiftwidth=4
set expandtab

" Default text width is 80
set textwidth=80

" Show matching bracket
set showmatch

set ignorecase " searches are case insensitive...
set smartcase  " ... unless they contain at least one capital letter

set formatoptions+=j " Delete comment character when joining commented lines

let mapleader=","

" Highlight column after textwidth
" set colorcolumn=+1
" highlight ColorColumn ctermbg=darkgrey

" Show current git branch. Used in statusline
function! GitBranch()
  return system("git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d '\n'")
endfunction

" Use buffer words as default tab completion
"let g:SuperTabDefaultCompletionType = '<C-x><C-o>'
inoremap <C-Space> <C-x><C-o>
inoremap <C-@> <C-Space>

" ----------------------------------------------
"  NerdTree
" ----------------------------------------------
map <Leader>n :NERDTreeToggle<CR>
let NERDTreeIgnore = ['\.pyc$']

" ----------------------------------------------
"  Indentation
" ----------------------------------------------
map <Leader>ig :IndentGuidesToggle<CR>

" ----------------------------------------------
" Fix trailing Whitespace
" ----------------------------------------------

" Autofix all whitespace on save
"autocmd BufWritePre *.py :%s/\s\+$//e
" Delete all trailing empty lines on files
"autocmd BufWritePre *.py :%s/\(\s*\n\)\+\%$//e

" Autofix all whitespace on save
" autocmd BufWritePre *.hs :%s/\s\+$//e
" Delete all trailing empty lines on files
" autocmd BufWritePre *.hs :%s/\(\s*\n\)\+\%$//e

" ----------------------------------------------
" GUI Options
" ----------------------------------------------

" Prevent buggy resizing with xmonad
set guiheadroom=0

set mouse=a
set mousemodel=popup

set guioptions-=m
set guioptions-=r
set guioptions-=T
set guioptions-=L
set background=dark

set wildmenu
set wildmode=longest:list

set dictionary="/usr/dict/words"

" Correct next line jump within wrapped lines
nmap j gj
nmap k gk

" Don't interrupt v-mode due indent. Thanks, kaero
vnoremap < <gv
vnoremap > >gv

" Center view on search result
nmap n nzz
nmap N Nzz
nmap * *zz
nmap # #zz
nmap g* g*zz
nmap g# g#zz

" Map BOL/EOL to 9/0 respectively
nmap 0 $
nmap 9 ^

" C-c and C-v - Copy/Paste to global clipboard
vmap <C-c> "+yi
imap <C-v> <esc>"+gpi

" Windows resizing
if bufwinnr(1)
    map + <C-W>3+
    map - <C-W>3-
    map . <C-W>3>
    map , <C-W>3<
endif

" Quick tab actions
" Don't override <tab> because in Vim it's the same as <c-i> which is jump
" forward (opposite to <c-o>). So remapping <tab> breaks jump forward.
nnoremap <S-tab> :tabnext<CR>

" Colors
if has("gui_running")
    " For gvim
    "colorscheme jellybeans
    "set guifont=Source\ Code\ Pro\ Medium\ 9
    "set anti enc=utf-8
else
    " For terminal
    "colorscheme jellybeans
    "set guifont=ProggyCleanTT\ 12
    autocmd FocusGained * call s:CommandTFlush()
endif

set termguicolors
colorscheme onedark

" Makes sure that colors are correct in tmux
let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
set background=dark
se t_Co=256

" ----------------------------------------------
" Flush
" ----------------------------------------------

" Flush swap files recursively in this directory, usefull if Vim
" crashes.
command! Flush :call Flush()
func! Flush()
    exec "!find . -name \".*.swp\" | xargs rm -f"
endfunc

" ----------------------------------------------
" HTML
" ----------------------------------------------
let g:mta_use_matchparen_group = 1

" ----------------------------------------------
" Haskell
" ----------------------------------------------
" let $PATH = $PATH . ':' . expand('~/.cabal/bin')

" " Reload
" map <silent> tu :call GHC_BrowseAll()<CR>

" " Type Lookup
" map tt :call GHC_ShowType(0)<CR>

" " Type Insertion
" map <silent> tw :GhcModTypeInsert<CR>
" map <silent> ts :GhcModSplitFunCase<CR>
" map <silent> tq :GhcModType<CR>
" map <silent> te :GhcModTypeClear<CR>

" au FileType haskell nnoremap <buffer> <F1> :GhcModType<CR>
" au FileType haskell nnoremap <buffer> <F2> :GhcModTypeClear<CR>

" noremap <silent> <C-S> :update<CR>

" function! Pointfree()
"   call setline('.', split(system('pointfree '.shellescape(join(getline(a:firstline, a:lastline), "\n"))), "\n"))
" endfunction
" vnoremap <silent> <leader>h. :call Pointfree()<CR>

" nmap <silent> <leader>hl :SyntasticCheck hlint<CR>

" " Disable haskell-vim omnifunc
" let g:haskellmode_completion_ghc = 1
" autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

" ----------------------------------------------
" Syntastic
" ----------------------------------------------
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0

"let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['haskell'] }

" ----------------------------------------------
" Python
" ----------------------------------------------
autocmd bufnewfile,bufread *.py set formatprg=par

" ----------------------------------------------
" Other Languages
" ----------------------------------------------
autocmd BufNewFile,BufRead *.agda set filetype=agda
autocmd BufNewFile,BufRead *.idr set filetype=idris
autocmd BufNewFile,BufRead *.ocaml set filetype=ocaml
autocmd BufNewFile,BufRead *.go set filetype=go
autocmd BufNewFile,BufRead *.pure set filetype=pure
autocmd BufRead,BufNewFile *.ws set filetype=wist
autocmd BufNewFile,BufRead *.js set filetype=javascript
autocmd BufNewFile,BufRead *.coffee set filetype=coffee
autocmd BufNewFile,BufRead *.md set filetype=markdown
autocmd BufNewFile,BufRead *.ll set filetype=llvm
autocmd BufNewFile,BufRead *.scala set filetype=scala
autocmd BufNewFile,BufRead *.c set filetype=c
autocmd BufNewFile,BufRead *.sol set filetype=solidity
autocmd BufNewFile,BufRead *.journal set filetype=ledger
autocmd BufNewFile,BufRead *.ledger set filetype=ledger


" ----------------------------------------------
" Pane Switching
" ----------------------------------------------
nnoremap <C-j> <C-W>w

nnoremap <C-j> <C-W>w

" tab navigation like firefox
map tn :tabnext<CR>
map tp :tabprevious<CR>

map <C-t> :tabnew<CR>

highlight SpellBad term=underline gui=underline guisp=Blue
highlight Error term=underline gui=underline guibg=#00ff00

"------------------------------------------------------------
" Window split
"------------------------------------------------------------
" Make splits equal size
noremap <silent> <F12> :wincmd =<CR>
autocmd VimResized * wincmd =

" ----------------------------------------------
" Autocorect
" ----------------------------------------------
ab teh the
ab sefl self
ab equivelant equivalent
ab seperator separator

" ----------------------------------------------
" Tabularize
" ----------------------------------------------
let g:haskell_tabular = 1

vmap a= :Tabularize /=<CR>
vmap a; :Tabularize /::<CR>
vmap a, :Tabularize /,<CR>
vmap a- :Tabularize /-><CR>

" ----------------------------------------------
" Fast Navigation
" ----------------------------------------------
" Go to last edited line one keystroke 
map ` g;

" Go to last buffer
map gl <C-^> 

" ----------------------------------------------
" Searching
" ----------------------------------------------
set incsearch
map ff /\c

if &t_Co > 2 || has("gui_running")
    set hlsearch                "Highlight all search matches if color is
endif                           "possible (:noh to toggle off)
nnoremap <silent> <return> :noh<return>

" ----------------------------------------------
" Inactive Buffers
" ----------------------------------------------
function! Wipeout()
  " list of *all* buffer numbers
  let l:buffers = range(1, bufnr('$'))

  " what tab page are we in?
  let l:currentTab = tabpagenr()
  try
    " go through all tab pages
    let l:tab = 0
    while l:tab < tabpagenr('$')
      let l:tab += 1

      " go through all windows
      let l:win = 0
      while l:win < winnr('$')
        let l:win += 1
        " whatever buffer is in this window in this tab, remove it from
        " l:buffers list
        let l:thisbuf = winbufnr(l:win)
        call remove(l:buffers, index(l:buffers, l:thisbuf))
      endwhile
    endwhile

    " if there are any buffers left, delete them
    if len(l:buffers)
      execute 'bwipeout' join(l:buffers)
    endif
  finally
    " go back to our original tab page
    execute 'tabnext' l:currentTab
  endtry
endfunction

" ----------------------------------------------
" Writing Mode
" ----------------------------------------------
autocmd BufNewFile,BufRead *.rst,*.txt,*.tex,*.latex,*.md setlocal spell
autocmd BufNewFile,BufRead *.rst,*.txt,*.tex,*.latex,*.md setlocal nonumber

" ----------------------------------------------
" Clipboard
" ----------------------------------------------
noremap <F9> :set invpaste paste?<CR>
set pastetoggle=<F9>

" ----------------------------------------------
" Vim Workspace
" ----------------------------------------------
nnoremap <leader>W :ToggleWorkspace<CR>
let g:workspace_session_name = 'Session.vim'
let g:workspace_session_directory = $HOME . '/.vim/sessions/'
let g:workspace_session_disable_on_args = 1
let g:workspace_persist_undo_history = 1
let g:workspace_undodir = $HOME . '/.vim/undodir/'
let g:workspace_autosave_always = 1
let g:workspace_autosave_ignore = ['gitcommit']

" ----------------------------------------------
" Deoplete autocompletion
" ----------------------------------------------
let g:deoplete#enable_at_startup = 1
let g:SuperTabDefaultCompletionType = "<c-n>"

" ----------------------------------------------
" Cscope (find usages)
" ----------------------------------------------
function! Cscope(option, query)
  let color = '{ x = $1; $1 = ""; z = $3; $3 = ""; printf "\033[34m%s\033[0m:\033[31m%s\033[0m\011\033[37m%s\033[0m\n", x,z,$0; }'
  let opts = {
  \ 'source':  "cscope -dL" . a:option . " " . a:query . " | awk '" . color . "'",
  \ 'options': ['--ansi', '--prompt', '> ',
  \             '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
  \             '--color', 'fg:188,fg+:222,bg+:#3a3a3a,hl+:104'],
  \ 'down': '40%'
  \ }
  function! opts.sink(lines) 
    let data = split(a:lines)
    let file = split(data[0], ":")
    execute 'e ' . '+' . file[1] . ' ' . file[0]
  endfunction
  call fzf#run(opts)
endfunction

" Invoke command. 'g' is for call graph, kinda.
nnoremap <silent> <Leader>g :call Cscope('3', expand('<cword>'))<CR>


" FZF
" fzf.vim mappings
nnoremap <leader>; :Buffers<CR>
nnoremap <leader>f :Files<CR>
nnoremap <leader>T :Tags<CR>
nnoremap <leader>t :BTags<CR>
nnoremap <leader>s :Ag<CR>
nnoremap <leader>h :GitMessenger<CR>
nnoremap <leader>/ :History/<CR>
nnoremap <leader>: :History:<CR>
nnoremap <leader>gc :Commits<CR>
nnoremap <leader>gbc :BCommits<CR>
nnoremap <leader>gs :GFiles?<CR>

let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit' }

" Gutentags
let g:gutentags_ctags_tagfile = '.tags'
let g:gutentags_modules = ['ctags', 'cscope']
let g:gutentags_file_list_command = 'ag -l'
let g:gutentags_define_advanced_commands = 1
let g:gutentags_exclude_filetypes = ['vim', 'markdown', 'text', 'config', 'yaml']


" F11 - Show tagbar list
let g:tagbar_left=1
nmap <F11> :TagbarToggle<CR>
imap <F11> <esc>:TagbarToggle<CR>
vmap <F11> <esc>:TagbarToggle<CR>

"" F12 - Files
nnoremap <F12> :NERDTreeToggle<cr>
vnoremap <F12> <esc>:NERDTreeToggle<cr>i
inoremap <F12> <esc>:NERDTreeToggle<cr>i

" Surround shortcut to correctly wrap word 
nmap ysw ysiW

" Ledger
let g:ledger_maxwidth = 80
let g:ledger_fillstring = '    -'
let g:ledger_fold_blanks = 0
let g:ledger_bin = '/home/robert/.cabal/bin/hledger'


" Writing
augroup pencil
autocmd!
autocmd filetype markdown,mkd call pencil#init()
   \ | call lexical#init()
   \ | call litecorrect#init()
   \ | setl spell spl=en_us fdl=4 noru nonu nornu
   \ | setl fdo+=search
augroup END
let g:pencil#wrapModeDefault = 'soft'
let g:pencil#textwidth = 74
let g:pencil#joinspaces = 0
let g:pencil#cursorwrap = 1
let g:pencil#conceallevel = 3
let g:pencil#concealcursor = 'c'
let g:pencil#softDetectSample = 20
let g:pencil#softDetectThreshold = 130
